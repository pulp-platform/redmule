# Command line tool to sumarize the vulnerability based on a vulnerability output by Injectafault
# Prints a Tree structure with each wire that is vulnerable, something like this:
# i_dut                                                                           
# - dst_fmt_i                                                                      Faulty [   1/   3] (4: Stall)
# - gen_in_dmr                                                                    
# - - gen_in_oo_retry                                                             
# - - - i_retry_start                                                             
# - - - - data_i.op                                                                Faulty [   1/   5] (2: Wrong Output)
# - - - - failed_valid_d                                                           Faulty [   5/   7] (2: Wrong Output)
# - - i_time_DMR_start                                                            
# - - - data_i.op                                                                  Faulty [   2/   3] (2: Wrong Output)
# - - - data_i.tag                                                                 Faulty [   1/   5] (2: Wrong Output)
# ...
#
# Usage: python3 vulnerability_summary.py <vulnerability_csv_file>
#
# Author: Maurus Item <itemm@student.ethz.ch>


import csv
import sys

fault_type_dict = {
    1: "State Difference",
    2: "Wrong Output",
    3: "X/Z Output",
    4: "Stall",
    5: "Retry",
    6: "Retry (Unneccesary)",
}


class bcolors:
    HEADER = '\033[95m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    RESET = '\033[0m'
    FAILRED = '\033[91m'


class Node:
    def __init__(self, name):
        self.name = name
        self.children = {}
        self.fault_types = set()
        self.seeds = set()
        self.fault_count = 0
        self.total_count = 0


    def add(self, fault_type, seed):
        if fault_type > 0 and fault_type < 5:
            self.fault_types.add(fault_type)
            self.seeds.add(seed)
            self.fault_count += 1

        self.total_count += 1

    @property
    def has_fault(self):
        return len(self.fault_types) > 0

    @property
    def child_has_fault(self):
        return any([c.has_fault or c.child_has_fault for c in self.children.values()])

    def __str__(self, prefix="", show_good=True):
        fault_types_str = ", ".join([f"{x}: {fault_type_dict[x]}" for x in self.fault_types])
        prefixed_name = f"{prefix}{self.name}"

        if self.has_fault:
            if len(self.seeds) == 0:
                seed_str = ""
            elif len(self.seeds) <= 6:
               seed_str = "{" + ", ".join(map(str, sorted(self.seeds))) + "}"
            else:
               seed_str = "{" + ", ".join(map(str, sorted(self.seeds)[:6])) + ", ...}"
            return f"{bcolors.FAILRED}{prefixed_name:80s} Faulty [{self.fault_count:4}/{self.total_count:4}] ({fault_types_str:25s}) {seed_str}\n" 

        elif self.child_has_fault:
            return f"{bcolors.OKCYAN}{prefixed_name:80s}\n"
        else:
            if show_good:
                return f"{bcolors.OKGREEN}{prefixed_name:80s}\n"
            else:
                return ""

def add_net(root, net_name, fault_type, seed, group=False):
    current_node = root
    
    # Traverse tree
    for segment in net_name.split('/'):

        # Remove same nets with different generate ID
        if group:
            segment = segment.rstrip("[0123456789]")

        if segment not in current_node.children:
            current_node.children[segment] = Node(segment)
        current_node = current_node.children[segment]

    # Add fault to final node
    current_node.add(fault_type, seed)


def build_tree_from_csv(csv_file, group=False):
    root = Node("")
    with open(csv_file, newline='') as file:
        reader = csv.DictReader(file)
        for row in reader:

            # Check if fault injection lines up with clock and exclude
            if int(row['termination_cause']) > 0 and (int(row['injection_time']) % 10) == 5:
                continue

            add_net(root, row['injected_net_name'], int(row['termination_cause']), int(row['seed']), group=group)
    return root


def print_tree(node, depth=-4, show_good=True):
    if depth >= 0:
        prefix = "- " * depth
        print(node.__str__(prefix=prefix, show_good=show_good), end="")
    
    for child in sorted(node.children.values(), key=lambda x: x.name):
        print_tree(child, depth + 1, show_good=show_good)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python analysis.py <input_csv_file>")
        sys.exit(1)
    
    csv_file = sys.argv[1]
    tree_root = build_tree_from_csv(csv_file, group=True)
    print_tree(tree_root, show_good=False)
    print(bcolors.RESET)
